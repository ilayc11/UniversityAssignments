בכלליות - 
בכל המבנים שיצרתי הנחתי שהמשתמש יייצר מבנה, יצור אובייקט שכולל הקצאת זיכרון ויכניס אותו לאחד המבנים שיצר. אני בחרתי שהמחיקה של האובייקט תקרא כחלק מהמחיקה
של המבנה, לא רציתי שהמבנה ייצר בעצמו את האובייקט שוב, ולכן עשיתי פונקציות פשוטות של קאסטינג שמתאימות עצמן למבנה המתאים, כלומר כל אלמנט שיוכנס למבנה יועתק בצורה שטחית לתוך המבנה.

LinkedList-
בחרתי לממש את הLinkedList על ידי מימוש של Node, כאשר בכל Node מוכל לי אלמנט ג'נרי, והרשימה עצמה תהיה דו כיוונית. ניתן היה לבצע זאת עם רשימה חד כיוונית
אך מנוחות אישית בחרתי בדרך הזו. ביצירה, הרשימה מקבלת את כל הפונקציות שהיא צריכה מבחוץ ומעתיקה באופן שטחי את האלמנטים לתוכה, זאת אומרת ללא הקצאת זיכרון נוספת
אלא רק עי קאסטינג. בעת מחיקה של הרשימה, ימחקו כל הNode וכל האלמנטים שבתוכם כדי למנוע דליפות זיכרון.

KeyValuePair- 
אין יותר מדי מה לומר, מבנה פשוט שמכיל שני אלמנטים ומקבל את כל הפונקציות שהוא צריך מבחוץ.

HashTable- 
ימומש על ידי מערך של רשימות מקושרות, כאשר כל רשימה תהיה מורכבת מKeyValuePair. בכדי שהרשימות יתאימו את עצמן לאלמנטים של KeyValuePair, נדרש היה 
ליצור פונקציות בתוך HashTable בהן נשתמש בעת יצירת הרשימות המקושרות בכל תא במערך. copyKVP,freeKVP,displayKVP,equalKVP. ביצירת טבלאת ההאש אנו מקבלים
פונקציות חיצוניות אותן נרצה לשמור כחלק מהמבנה בכדי להשתמש במודול עצמו.

MultiValueHashTable-
ימומש על ידי טבלאת האש בלבד, כאשר ערכי הvalues שישלחו כעת לתוך הטבלה יהיו עטופים כחלק מLinkedList. על כן היה צורך במימוש פונקציות מתאימות אשר יישלחו
לטבלאת האש ויאפשרו מימוש כרשימה. copyKMVP,FreeKMVP,printKMVP. בעבודה לא נאמר אם בהוספה של מפתח וערך כלשהם מופיעים כבר בטבלה, על כן לא נבדקו כפילויות של 
values אלא רק של מפתחות. נשאר להחלטת המשתמש.

Jerry-
הוספתי פונקציות בכדי להתאים את ג'רי לעבודה החדשה, מבלי לשנות את הפונקציונליות שלו מהעבודה הקודמת. (בעיקר בכדי לייבא מידע שכבר קיים כבר בתוך הג'רי).
getJerryID מייבאת ת.ז. של ג'רי
 getPhysName מייבאת את שם התכונה
getPlanetName מייבאת את שם הכוכב של ג'רי
 getNumOfPhys מייבאת את מס' התכונות בג'רי
 getHappinessLevel מייבאת את רמת השמחה של ג'רי
 setHappinessLevel משנה את רמת השמחה של ג'רי
 getPhysByIndex מייבאת תכונה לפי אינדקס (מתחילה מ1)

JerryBoree-
את הקובץ הראשי אני מממש באמצעות 3 מבני נתונים עיקריים-
AllJerries הוא רשימה מקושרת שתמיד מכילה את כל הג'רים לאורך כל התוכנית, שימושית לביצוע פעולות בהן אנחנו צריכים את כל הג'רים. תשומש גם לקליטה שלהם מהקובץ.
JerryIDKeyJerryVal טבלאת hash רגילה אשר מכילה גם את כל הג'רים, שימושית כאשר רוצים להגיע לג'רי ספציפי ויש לעשות זאת בזמן ריצה מתאים, המפתח הוא הת.ז. והערך מסוג Jerry*
PNameKeyJerryVal טבלאת MultiValue, שם של תכונה יהיה מפתח וכל הג'רים אשר מכילים את התכונה הנ"ל יהיו חלק מהvalues של התכונה.
arrPlanets מערך של כל הכוכבים, בדומה לעבודה הקודמת.
בכדי שלא יהיו לנו בעיות עם מחיקות כפולות, נרצה להשתמש בפונקציות מחיקה "מזוייפות", אשר מקבלות אלמנט ולא עושות איתו כלום. המחיקה האמיתית תתבצע ברשימת AllJerries.
תחילה אנחנו נקרא מהקובץ, נוסיף את הכוכבים לarrPlanets, את הגרים לAllJerries, ואת התכונות לכל ג'רי בהתאמה. לאחר מכן ניצור את שאר מבני הנתונים. 
את גודל טבלאות ההאש נבחר להיות המספר הראשוני הגדול הקרוב ביותר למספר הג'רים כדי שנוכל להבטיח שבקירוב טוב לפחות בתחילת התוכנית הדברים יתבצעו בo(1). על כן הוספתי שתי פונקציות שמטרתן למצוא את המספר הראשוני הקרוב ביותר.
כמובן הגודל לא יכול להיות תלוי במספר התכונות כי מצב אפשרי הוא שלכל הג'רים אין תכונות כלל, ולא מתאפשר טבלה בגודל 0.
נעבור על כל הג'רים והתכונות שלהם ונוסיף אותם לטבלאות המתאימות.
לאחר מכן מתחיל החלק העיקרי של המיין בו מתחילים לעבוד עם קלט המספרים מהמשתמש. הדגש הכי  חשוב לחלק זה הוא שבהוספה של ג'רים מוסיפים לכל מבני הנתונים שאיתחלנו, ובהסרה מסירים באמת רק מרשימת AllJerreis ובשאר המבנים מסירים ב"כאילו".
במציאת הג'רי העצוב ביותר לא התבצעה התחשבות בזמן ריצה, המציאה רצה בזמן O(N) , לא היה נראה כי הסעיף הזה מספיק חשוב כדי להקדיש רק לו מבנה נתונים חדש, המבנה היה צריך להיות מולטי האש בגודל 100 וטבלה כזאת הייתה יכולה להיות בזבזנית מאוד מבחינת מקום,
נראה כי דווקא היה עדיף לבזבז זמן ריצה מאשר לבזבז מקום. 
